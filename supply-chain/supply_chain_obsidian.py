"""Generate Obsidian notes from the supply chain mention database.

For each ticker with mentions, generates a {TICKER}_mentions.md file
in the Obsidian Vault with "Mentioned By" and "Mentions" tables.
"""

import sys
from datetime import datetime
from pathlib import Path

# Add skills root so shared imports work
sys.path.insert(0, r"C:\Users\thisi\.claude\skills")

from supply_chain_db import get_mentions_by, get_mentions_for, get_stats

OBSIDIAN_DIR = Path.home() / "Documents" / "Obsidian Vault" / "Supply Chain"


def generate_mention_note(ticker: str) -> Path | None:
    """Generate an Obsidian mention note for a single ticker.

    Returns the output Path, or None if no mentions exist.
    """
    ticker = ticker.upper()
    mentioned_by = get_mentions_for(ticker)  # Others mentioning this ticker
    mentions = get_mentions_by(ticker)  # This ticker mentioning others

    if not mentioned_by and not mentions:
        return None

    OBSIDIAN_DIR.mkdir(parents=True, exist_ok=True)
    output_path = OBSIDIAN_DIR / f"{ticker}_mentions.md"

    lines = []

    # YAML frontmatter
    lines.append("---")
    lines.append(f"tags: [supply-chain, mentions, {ticker}]")
    lines.append(f"date: {datetime.now().strftime('%Y-%m-%d')}")
    lines.append(f"ticker: {ticker}")
    lines.append("generated: true")
    lines.append("framework_sections: [S2]")  # Supply chain → Competitive Landscape
    lines.append("---")
    lines.append("")

    lines.append(f"# {ticker} Supply Chain Mentions")
    lines.append("")
    lines.append(
        f"*Auto-generated from earnings transcript analysis. "
        f"Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M')}*"
    )
    lines.append("")

    # ── Summary ──
    unique_mentioners = len(
        set(m["source_ticker"] for m in mentioned_by if m.get("source_ticker"))
    )
    unique_mentioned = len(
        set(m["mentioned_ticker"] or m["mentioned_company"] for m in mentions)
    )
    lines.append("## Summary")
    lines.append("")
    lines.append(
        f"- **Mentioned by** {unique_mentioners} companies ({len(mentioned_by)} total mentions)"
    )
    lines.append(
        f"- **Mentions** {unique_mentioned} companies ({len(mentions)} total mentions)"
    )
    lines.append("")

    # ── Mentioned By (who talks about this ticker) ──
    if mentioned_by:
        lines.append("## Mentioned By")
        lines.append("")
        lines.append(
            "Companies that mention [[" + ticker + "]] in their earnings calls:"
        )
        lines.append("")
        lines.append("| Source | Quarter | Speaker | Quote |")
        lines.append("|--------|---------|---------|-------|")

        for m in mentioned_by:
            source_ticker = m.get("source_ticker", "?")
            source_display = (
                f"[[{source_ticker}]]"
                if source_ticker
                else m.get("source_company", "?")
            )
            quarter = m.get("transcript_quarter", "")
            role = m.get("speaker_role", "")
            # Truncate context for table readability, escape pipes
            context = m["context"][:150].replace("|", "\\|").replace("\n", " ")
            if len(m["context"]) > 150:
                context += "..."
            review_mark = " *" if m.get("needs_review") else ""
            lines.append(
                f"| {source_display} | {quarter} | {role} | {context}{review_mark} |"
            )

        lines.append("")

    # ── Mentions (who this ticker talks about) ──
    if mentions:
        lines.append("## Mentions")
        lines.append("")
        lines.append(f"Companies that [[{ticker}]] mentions in its earnings calls:")
        lines.append("")
        lines.append("| Mentioned | Quarter | Speaker | Quote |")
        lines.append("|-----------|---------|---------|-------|")

        for m in mentions:
            mentioned_ticker = m.get("mentioned_ticker")
            if mentioned_ticker:
                mentioned_display = f"[[{mentioned_ticker}]]"
            else:
                mentioned_display = m.get("mentioned_company", "?")
            quarter = m.get("transcript_quarter", "")
            role = m.get("speaker_role", "")
            context = m["context"][:150].replace("|", "\\|").replace("\n", " ")
            if len(m["context"]) > 150:
                context += "..."
            review_mark = " *" if m.get("needs_review") else ""
            lines.append(
                f"| {mentioned_display} | {quarter} | {role} | {context}{review_mark} |"
            )

        lines.append("")

    # ── Footer ──
    lines.append("---")
    lines.append("")
    lines.append("*\\* = needs review (low-confidence entity match)*")
    lines.append("")
    lines.append("Generated by Supply Chain Cross-Reference v0")

    output_path.write_text("\n".join(lines), encoding="utf-8")
    return output_path


def generate_all_notes() -> int:
    """Generate Obsidian notes for all tickers with mentions.

    Returns the number of notes generated.
    """
    stats = get_stats()
    count = 0

    # Collect all tickers that appear as source or mentioned
    tickers = set()
    for r in stats.get("top_mentioned", []):
        if r.get("mentioned_ticker"):
            tickers.add(r["mentioned_ticker"])
    for r in stats.get("top_mentioners", []):
        if r.get("source_ticker"):
            tickers.add(r["source_ticker"])

    # Also query the database directly for complete coverage
    from supply_chain_db import get_db

    conn = get_db()
    try:
        rows = conn.execute(
            "SELECT DISTINCT source_ticker FROM company_mentions WHERE source_ticker IS NOT NULL"
        ).fetchall()
        for row in rows:
            tickers.add(row[0])

        rows = conn.execute(
            "SELECT DISTINCT mentioned_ticker FROM company_mentions WHERE mentioned_ticker IS NOT NULL"
        ).fetchall()
        for row in rows:
            tickers.add(row[0])
    finally:
        conn.close()

    print(f"Generating Obsidian notes for {len(tickers)} tickers...")

    for ticker in sorted(tickers):
        result = generate_mention_note(ticker)
        if result:
            count += 1
            print(f"  Generated: {result.name}")

    print(f"\nDone. {count} notes written to {OBSIDIAN_DIR}")
    return count


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Generate Obsidian notes from supply chain mention database"
    )
    parser.add_argument(
        "ticker",
        nargs="?",
        default=None,
        help="Generate note for a specific ticker (or all if omitted)",
    )
    args = parser.parse_args()

    if args.ticker:
        result = generate_mention_note(args.ticker)
        if result:
            print(f"Generated: {result}")
        else:
            print(f"No mentions found for {args.ticker.upper()}")
    else:
        generate_all_notes()
